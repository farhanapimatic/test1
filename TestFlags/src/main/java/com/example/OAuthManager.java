/*
 * TestFlags
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package com.example;

import android.util.Base64;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.example.models.OAuthScopeEnum;
import com.example.controllers.OAuthAuthorizationController;
import com.example.models.OAuthTokenModel;
import com.example.models.CreateRequestTokenInputBuilder;
import com.example.models.CreateRefreshTokenInputBuilder;
import com.example.exceptions.APIException;
import com.example.http.client.APICallBack;
import com.example.http.client.HttpContext;

/**
 * Utility class for OAuth 2 authorization and token management
 */
public class OAuthManager {
    /**
     * The reference to singleton instance of this class
     */
    private static OAuthManager instance;

    /**
     * Singleton instance of OAuth 2 API controller 
     */
    private OAuthAuthorizationController oAuthApi;

    /**
     * Constructor
     */
    private OAuthManager() {
        oAuthApi = OAuthAuthorizationController.getInstance();
    }

    /**
     * Returns the *Singleton* instance of this class.
     * @return Singleton instance
     */
    public static OAuthManager getInstance() {
        if (instance == null) {
            synchronized (OAuthManager.class) {
                if (instance == null) {
                    instance = new OAuthManager();
                }
            }
        }
        return instance;
    }

    /**
     * Build an authorization URL for taking the user's consent to access data
     * @param scope List of scopes needed
     * @param state An opaque state string
     * @param additionalParameters Additional parameters to add the the authorization URL
     * @return Authorization URL
     */
    public String buildAuthorizationUrl(final List<OAuthScopeEnum> scope, final String state,
            final Map<String, String> additionalParameters) {
        
        // the uri for api requests
        StringBuilder queryBuilder = new StringBuilder(Configuration.baseUri);
        queryBuilder.append("/swe");

        // build query params
        Map<String, Object> queryParameters = new HashMap<String, Object>() {
            private static final long serialVersionUID = 1L;
            {
                put("response_type", "code");
                put("client_id", Configuration.oAuthClientId);
                put("redirect_uri", Configuration.oAuthRedirectUri);
                put("scope", stringJoin(scope, " "));
                put("state", state);
            }
        };

        // process optional query parameters
        if (additionalParameters != null)
            queryParameters.putAll(additionalParameters);

        APIHelper.appendUrlWithQueryParameters(queryBuilder, queryParameters);

        // validate and preprocess url
        return APIHelper.cleanUrl(queryBuilder);
    }
    
    /**
     * Build an authorization URL for taking the user's consent to access data
     * @return Authorization URL
     */
    public String buildAuthorizationUrl() {
        return buildAuthorizationUrl(null, null, null);
    }
    /**
     * Build an authorization URL for taking the user's consent to access data
     * @param scopes List of scopes needed
     * @return Authorization URL
     */
    public String buildAuthorizationUrl(final List<OAuthScopeEnum> scopes) {
        return buildAuthorizationUrl(scopes, null, null);
    }

    /**
     * Build an authorization URL for taking the user's consent to access data
     * @param scopes List of scopes needed
     * @param state An opaque state string
     * @return Authorization URL
     */
    public String buildAuthorizationUrl(final List<OAuthScopeEnum> scopes, final String state) {
        return buildAuthorizationUrl(scopes, state, null);
    }

    /**
     * Asynchronously authorize the client with the OAuth provider
     * @param authorizationCode Authorization code returned by the OAuth provider
     * @param additionalParameters Additional parameters to send during authorization
     * @param callback Callback
     */
    public void authorizeAsync(final String authorizationCode, final Map<String, Object> additionalParameters,
            final APICallBack<OAuthTokenModel> callback) {
        
        final Map<String, Object> aparams = additionalParameters == null ? new HashMap<String, Object>()
                : additionalParameters;

        CreateRequestTokenInputBuilder input = new CreateRequestTokenInputBuilder();
        input.authorization(getBasicAuthForClient())
            .code(authorizationCode)
            .redirectUri(Configuration.oAuthRedirectUri)
            ;
        
        oAuthApi.createRequestTokenAsync(
            input.build(),
            aparams,
            new APICallBack<OAuthTokenModel>() {

                    public void onSuccess(HttpContext context, OAuthTokenModel response) {
                        updateOAuthToken(response);
                        callback.onSuccess(context, response);
                    }

                    public void onFailure(HttpContext context, Throwable error) {
                        callback.onFailure(context, error);
                    }
                });
    }
    
    /**
     * Asynchronously authorize the client with the OAuth provider
     * @param authorizationCode Authorization code returned by the OAuth provider
     * @param callback Callback
     */
    public void authorizeAsync(final String authorizationCode, final APICallBack<OAuthTokenModel> callback) {
        authorizeAsync(authorizationCode, null, callback);
    }

    /**
     * Refresh the OAuth token
     * @param scope List of scopes needed. Should only be passed if scopes need to be changed.
     * @param additionalParameters Additional parameters to send during token refresh
     * @param callback Callback
     */
    public void refreshTokenAsync(final List<OAuthScopeEnum> scope, final Map<String, Object> additionalParameters,
            final APICallBack<OAuthTokenModel> callback) {
        
        final Map<String, Object> aparams = additionalParameters == null ? new HashMap<String, Object>()
                : additionalParameters;
        CreateRefreshTokenInputBuilder input = new CreateRefreshTokenInputBuilder();
        input.authorization(getBasicAuthForClient())
             .refreshToken(Configuration.oAuthToken.getRefreshToken())
             .scope(stringJoin(scope, " "));
        
        oAuthApi.createRefreshTokenAsync(input.build(), aparams, new APICallBack<OAuthTokenModel>() {

                    public void onSuccess(HttpContext context, OAuthTokenModel response) {
                        updateOAuthToken(response);
                        callback.onSuccess(context, response);
                    }

                    public void onFailure(HttpContext context, Throwable error) {
                        callback.onFailure(context, error);
                    }
                });
    }

    /**
     * Refresh the OAuth token
     * @param scope List of scopes needed. Should only be passed if scopes need to be changed.
     * @param callback Callback
     */
    public void refreshTokenAsync(final List<OAuthScopeEnum> scope, final APICallBack<OAuthTokenModel> callback) {
        refreshTokenAsync(scope, null, callback);
    }
    
    /**
     * Refresh the OAuth token
     * @param callback Callback
     */
    public void refreshTokenAsync(final APICallBack<OAuthTokenModel> callback) {
        refreshTokenAsync(null, null, callback);
    }

    /**
     * Has the OAuth token expired?
     * @return True if expired
     */
    public boolean isTokenExpired() {
        return Configuration.oAuthToken != null
                && Configuration.oAuthToken.getExpiry() < (System.currentTimeMillis() / 1000L);
    }

    /**
     * Create authorization header for API calls
     * @return Authorization header
     */
    public String getAuthorizationHeader() {
        return "Bearer " + Configuration.oAuthToken.getAccessToken();
    }

    /**
     * Update OAuth token in configuration
     * @param oAuthToken OAuth token
     */
    private static void updateOAuthToken(OAuthTokenModel oAuthToken) {
        //calculate token expiry time in unix time (UTC)
        if (oAuthToken.getExpiresIn() != null && oAuthToken.getExpiresIn() != 0) {
            oAuthToken.setExpiry((System.currentTimeMillis() / 1000L) + oAuthToken.getExpiresIn());
        }

        //update token and call callback
        Configuration.oAuthToken = oAuthToken;
        if (Configuration.oAuthTokenUpdateCallBack != null) {
            Configuration.oAuthTokenUpdateCallBack.tokenUpdate(oAuthToken);
        }
    }

    /**
     * Build authorization header value for basic auth
     * @return Authorization header value for this client
     */
    private static String getBasicAuthForClient() {
        String val = Configuration.oAuthClientId + ":" + Configuration.oAuthClientSecret;
        return "Basic " + Base64.encodeToString(val.getBytes(), Base64.NO_WRAP);
    }

    /**
     * Join string collection elements using delimiter
     * @param col String collection to join
     * @param delim Delimiter
     * @return String joined by delimiter
     */
    private static String stringJoin(Collection<?> col, String delim) {
        if (col == null)
            return null;
        StringBuilder sb = new StringBuilder();
        Iterator<?> iter = col.iterator();
        if (iter.hasNext())
            sb.append(iter.next().toString());
        while (iter.hasNext()) {
            sb.append(delim);
            sb.append(iter.next().toString());
        }
        return sb.toString();
    }
}
