/*
 * AdExchangeBuyerAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package com.googleapis.www.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import com.googleapis.www.*;
import com.googleapis.www.models.*;
import com.googleapis.www.exceptions.*;
import com.googleapis.www.http.client.HttpClient;
import com.googleapis.www.http.client.HttpContext;
import com.googleapis.www.http.request.HttpRequest;
import com.googleapis.www.http.response.HttpResponse;
import com.googleapis.www.http.response.HttpStringResponse;
import com.googleapis.www.http.client.APICallBack;

public class PretargetingConfigController extends BaseController {    
    //private static variables for the singleton pattern
    private static Object syncObject = new Object();
    private static PretargetingConfigController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the PretargetingConfigController class 
     */
    public static PretargetingConfigController getInstance() {
        synchronized (syncObject) {
            if (null == instance) {
                instance = new PretargetingConfigController();
            }
        }
        return instance;
    }

    /**
     * Deletes an existing pretargeting config.
     * @param    accountId    Required parameter: The account id to delete the pretargeting config for.
     * @param    configId    Required parameter: The specific id of the configuration to delete.
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void deletePretargetingconfigsByAccountIdAsync(
                final String accountId,
                final String configId,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<DynamicResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}/{configId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5422882821730826610L;
            {
                    put( "accountId", accountId );
                    put( "configId", configId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5527098397561812753L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5716360099371886480L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().delete(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            DynamicResponse _result = new DynamicResponse(_response);

                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Gets a specific pretargeting configuration
     * @param    accountId    Required parameter: The account id to get the pretargeting config for.
     * @param    configId    Required parameter: The specific id of the configuration to retrieve.
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void getPretargetingconfigsByAccountIdAsync(
                final String accountId,
                final String configId,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<PretargetingConfig> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}/{configId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4684845388837876390L;
            {
                    put( "accountId", accountId );
                    put( "configId", configId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5610677414505102024L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5508045431227349780L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PretargetingConfig _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PretargetingConfig>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Inserts a new pretargeting configuration.
     * @param    accountId    Required parameter: The account id to insert the pretargeting config for.
     * @param    body    Required parameter: Example: 
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void insertPretargetingconfigsByAccountIdAsync(
                final String accountId,
                final PretargetingConfig body,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<PretargetingConfig> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5688246734539957962L;
            {
                    put( "accountId", accountId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5608002157463722097L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5757972083491421311L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(body));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PretargetingConfig _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PretargetingConfig>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieves a list of the authenticated user's pretargeting configurations.
     * @param    accountId    Required parameter: The account id to get the pretargeting configs for.
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void listPretargetingconfigsByAccountIdAsync(
                final String accountId,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<PretargetingConfigList> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5357380616218209656L;
            {
                    put( "accountId", accountId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5434187560319854239L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5030814565143761126L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PretargetingConfigList _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PretargetingConfigList>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Updates an existing pretargeting config. This method supports patch semantics.
     * @param    accountId    Required parameter: The account id to update the pretargeting config for.
     * @param    configId    Required parameter: The specific id of the configuration to update.
     * @param    body    Required parameter: Example: 
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void patchPretargetingconfigsByAccountIdAsync(
                final String accountId,
                final String configId,
                final PretargetingConfig body,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<PretargetingConfig> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}/{configId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5345331225555263993L;
            {
                    put( "accountId", accountId );
                    put( "configId", configId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5451917005442956787L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5641091675229667494L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().patchBody(_queryUrl, _headers, APIHelper.serialize(body));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PretargetingConfig _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PretargetingConfig>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Updates an existing pretargeting config.
     * @param    accountId    Required parameter: The account id to update the pretargeting config for.
     * @param    configId    Required parameter: The specific id of the configuration to update.
     * @param    body    Required parameter: Example: 
     * @param    alt    Optional parameter: Data format for the response. (Acceptable values are: "json")
     * @param    fields    Optional parameter: Selector specifying which fields to include in a partial response.
     * @param    key    Optional parameter: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param    oauthToken    Optional parameter: OAuth 2.0 token for the current user.
     * @param    prettyPrint    Optional parameter: Returns response with indentations and line breaks.
     * @param    quotaUser    Optional parameter: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
     * @param    userIp    Optional parameter: IP address of the site where the request originates. Use this if you want to enforce per-user limits.
     * @return    Returns the void response from the API call 
     */
    public void updatePretargetingconfigsByAccountIdAsync(
                final String accountId,
                final String configId,
                final PretargetingConfig body,
                final String alt,
                final String fields,
                final String key,
                final String oauthToken,
                final Boolean prettyPrint,
                final String quotaUser,
                final String userIp,
                final APICallBack<PretargetingConfig> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/pretargetingconfigs/{accountId}/{configId}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5375015515344031711L;
            {
                    put( "accountId", accountId );
                    put( "configId", configId );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4640928228345179379L;
            {
                    put( "alt", (alt != null) ? alt : "json" );
                    put( "fields", fields );
                    put( "key", key );
                    put( "oauth_token", oauthToken );
                    put( "prettyPrint", (prettyPrint != null) ? prettyPrint : true );
                    put( "quotaUser", quotaUser );
                    put( "userIp", userIp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4876609005907249193L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().putBody(_queryUrl, _headers, APIHelper.serialize(body));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            PretargetingConfig _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<PretargetingConfig>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

}